//# dp, modular arithmetic, combinatorics
//# => Represent N as N=QM+R. Do dp in order of the modulus and track the current k, q and r generated by either taking or not taking a representative of each modulus. Then distribute the remaining (Q-q) M values to the k chosen numbers.
#include <algorithm>
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <fstream>
#include <functional>
#include <iostream>
#include <iterator>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <string>
#include <utility>
#include <vector>

using namespace std;

const int mod = 1000000007;
inline int modadd(int a, int b) {
    a += b;
    return a>=mod ? a-mod : a;
}
inline int modmul(long long a, long long b) {
    a *= b;
    return int(a>=mod ? a%mod : a);
}
int fastexp(long long n, long long k) {
    long long ret = 1;
    while (k > 0) {
        if (k&1) ret = modmul(ret, n);
        n = modmul(n, n);
        k /= 2;
    }
    return int(ret);
}
inline int modinv(int n) {
    return fastexp(n, mod-2);
}

long long Q;
int R;
long long N;
int M;
int dp[55][55][55][55];
int F[55];
int inv[55];
int choose(long long n, int k) {
    n %= mod;
    int ret = 1;
    for (int i=0; i<k; ++i) {
        ret = modmul(ret, modadd(int(n), mod-i));
        ret = modmul(ret, inv[i+1]);
    }
    return ret;
}
int go(int m, int k, int q, int r) {
    int &ret = dp[m][k][q][r];
    if (ret != -1) {
        return ret;
    }
    if (m == M) {
        if (k==0 || r!=R || q>Q) {
            ret = 0;
        } else {
            ret = modmul(F[k], choose(Q-q+k-1, k-1));
        }
    } else {
        ret = go(m+1, k, q, r);
        r += m;
        if (r >= M) {
            r -= M;
            ++q;
        }
        ret = modadd(ret, go(m+1, k+1, q, r));
    }
    return ret;
}
class DistinctRemainders {
public:
    int howMany(long long N_, int M_) {
        N = N_;
        M = M_;
        Q = N/M;
        R = int(N - Q*M);
        F[0] = 1;
        for (int i=1; i<=M; ++i) {
            F[i] = modmul(F[i-1], i);
        }
        inv[1] = 1;
        for (int i=2; i<=M; ++i) {
            inv[i] = modinv(i);
        }
        memset(dp, 0xff, sizeof dp);
        return go(0, 0, 0, 0);
    }
};
